import os
import asyncio
import logging
import sys
from datetime import datetime
from discord.ext import commands
from dotenv import load_dotenv
from database import connect_db
import discord

# Configuraci√≥n de logging
def setup_logging():
    """Configurar sistema de logging"""
    # Crear directorio de logs si no existe
    os.makedirs('logs', exist_ok=True)
    
    # Formato de logs
    log_format = logging.Formatter(
        '%(asctime)s | %(levelname)s | %(name)s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Logger principal
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # Handler para consola
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(log_format)
    
    # Handler para archivo
    file_handler = logging.FileHandler(
        f'logs/bot_{datetime.now().strftime("%Y%m%d")}.log',
        encoding='utf-8'
    )
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(log_format)
    
    # Agregar handlers
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    # Configurar logging de discord.py
    discord_logger = logging.getLogger('discord')
    discord_logger.setLevel(logging.WARNING)
    
    return logging.getLogger(__name__)

# Configurar logging
logger = setup_logging()

# Cargar variables de entorno
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

# Verificaci√≥n de token
if not TOKEN:
    logger.critical("‚ùå Error: No se encontr√≥ DISCORD_TOKEN en el archivo .env")
    sys.exit(1)

# Configuraci√≥n de intents
intents = discord.Intents.default()
intents.members = True      
intents.message_content = True   
intents.invites = True 
intents.guilds = True
intents.guild_messages = True

# Lista de m√≥dulos a cargar
MODULES = [
    "modules.admin.admin",
    "modules.bump_tracker.bump_tracker",
    "modules.channel_control.channel_control", 
    "modules.economia.resenas",
    "modules.economia.economia",
    "modules.welcome.welcome",
    "modules.levels.levels",
    "modules.invites.invites",
    "modules.tickets.tickets",
    "modules.beginning.beginning",
    "modules.economia.sorteos",
    "modules.user.user",
    "modules.admin.partner",
    "modules.cuentas.cuentas",
]

class DiscordBot(commands.Bot):
    """Bot personalizado con funcionalidades extendidas"""
    
    def __init__(self):
        super().__init__(
            command_prefix="!",
            intents=intents,
            help_command=None,  # Deshabilitar comando help por defecto
            case_insensitive=True,
            strip_after_prefix=True
        )
        self.cogs_loaded = False
        self.start_time = datetime.now()
        
    async def setup_hook(self):
        """Configuraci√≥n inicial del bot (se ejecuta una sola vez)"""
        logger.info("üîß Ejecutando setup inicial...")
        await self.load_cogs()
        logger.info("‚úÖ Setup completado")
        
    async def load_cogs(self):
        """Carga todos los m√≥dulos del bot con manejo de errores individual"""
        if self.cogs_loaded:
            logger.info("‚ö†Ô∏è Los cogs ya est√°n cargados, saltando...")
            return
            
        logger.info("üì¶ Iniciando carga de m√≥dulos...")
        loaded_count = 0
        failed_count = 0
        
        for module in MODULES:
            try:
                await self.load_extension(module)
                module_name = module.split('.')[-1]
                logger.info(f"‚úÖ M√≥dulo '{module_name}' cargado correctamente")
                loaded_count += 1
            except Exception as e:
                module_name = module.split('.')[-1]
                logger.error(f"‚ùå Error cargando '{module_name}': {e}")
                failed_count += 1
        
        logger.info(f"üìä Resumen de carga: {loaded_count} exitosos, {failed_count} fallidos")
        
        if loaded_count == 0:
            logger.warning("‚ö†Ô∏è No se carg√≥ ning√∫n m√≥dulo. El bot funcionar√° con comandos b√°sicos solamente.")
        
        self.cogs_loaded = True
    
    async def on_ready(self):
        """Evento cuando el bot est√° completamente listo"""
        logger.info("=" * 60)
        logger.info(f"‚úÖ Bot conectado como {self.user}")
        logger.info(f"üìä Conectado a {len(self.guilds)} servidores")
        logger.info(f"üë• Alcance: {len(self.users)} usuarios")
        logger.info(f"üîß Discord.py versi√≥n: {discord.__version__}")
        logger.info(f"‚è∞ Tiempo de inicio: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Establecer estado del bot
        activity = discord.Activity(
            type=discord.ActivityType.watching,
            name=f"{len(self.guilds)} servidores | !help"
        )
        await self.change_presence(activity=activity)
        
        logger.info("=" * 60)
        logger.info("üöÄ Bot listo para usar!")
    
    async def on_guild_join(self, guild):
        """Evento cuando el bot se une a un servidor"""
        logger.info(f"‚úÖ Bot a√±adido al servidor: {guild.name} (ID: {guild.id}) - {guild.member_count} miembros")
        
        # Actualizar estado
        activity = discord.Activity(
            type=discord.ActivityType.watching,
            name=f"{len(self.guilds)} servidores | !help"
        )
        await self.change_presence(activity=activity)
    
    async def on_guild_remove(self, guild):
        """Evento cuando el bot es removido de un servidor"""
        logger.info(f"‚ùå Bot removido del servidor: {guild.name} (ID: {guild.id})")
        
        # Actualizar estado
        activity = discord.Activity(
            type=discord.ActivityType.watching,
            name=f"{len(self.guilds)} servidores | !help"
        )
        await self.change_presence(activity=activity)
    
    async def on_command_error(self, ctx, error):
        """Manejo global de errores de comandos"""
        if isinstance(error, commands.CommandNotFound):
            embed = discord.Embed(
                title="‚ùå Comando no encontrado",
                description=f"El comando `{ctx.invoked_with}` no existe.\nUsa `!help` para ver comandos disponibles.",
                color=0xff0000
            )
            await ctx.send(embed=embed, delete_after=10)
        elif isinstance(error, commands.MissingPermissions):
            embed = discord.Embed(
                title="üö´ Sin permisos",
                description="No tienes permisos para usar este comando.",
                color=0xff0000
            )
            await ctx.send(embed=embed, delete_after=10)
        elif isinstance(error, commands.CommandOnCooldown):
            embed = discord.Embed(
                title="‚è∞ Comando en cooldown",
                description=f"Espera {error.retry_after:.1f} segundos antes de usar este comando otra vez.",
                color=0xffa500
            )
            await ctx.send(embed=embed, delete_after=5)
        elif isinstance(error, commands.MissingRequiredArgument):
            embed = discord.Embed(
                title="‚ùå Argumento faltante",
                description=f"Faltan argumentos para el comando `{ctx.command}`.\nUsa `!help {ctx.command}` para m√°s informaci√≥n.",
                color=0xff0000
            )
            await ctx.send(embed=embed, delete_after=10)
        elif isinstance(error, commands.BadArgument):
            embed = discord.Embed(
                title="‚ùå Argumento inv√°lido",
                description=f"Argumento inv√°lido para el comando `{ctx.command}`.\nUsa `!help {ctx.command}` para m√°s informaci√≥n.",
                color=0xff0000
            )
            await ctx.send(embed=embed, delete_after=10)
        else:
            logger.error(f"Error no manejado en comando {ctx.command}: {error}", exc_info=True)
            embed = discord.Embed(
                title="‚ö†Ô∏è Error interno",
                description="Ocurri√≥ un error interno. El error ha sido registrado.",
                color=0xff0000
            )
            await ctx.send(embed=embed, delete_after=10)

# Crear instancia del bot
bot = DiscordBot()

# ========== COMANDOS B√ÅSICOS ==========

@bot.command(name="ping", help="Muestra la latencia del bot")
async def ping(ctx):
    """Comando para verificar la latencia del bot"""
    latency = round(bot.latency * 1000)
    embed = discord.Embed(
        title="üèì Pong!",
        description=f"Latencia: **{latency}ms**",
        color=0x00ff00
    )
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name}")
    await ctx.send(embed=embed)

@bot.command(name="info", aliases=["botinfo"], help="Informaci√≥n del bot")
async def bot_info(ctx):
    """Informaci√≥n detallada del bot"""
    uptime = datetime.now() - bot.start_time
    days = uptime.days
    hours, remainder = divmod(uptime.seconds, 3600)
    minutes, _ = divmod(remainder, 60)
    
    embed = discord.Embed(
        title="ü§ñ Informaci√≥n del Bot",
        description="Bot multiusos para Discord",
        color=0x00ffff
    )
    embed.add_field(name="üìä Servidores", value=len(bot.guilds), inline=True)
    embed.add_field(name="üë• Usuarios", value=len(bot.users), inline=True)
    embed.add_field(name="‚ö° Comandos", value=len(bot.commands), inline=True)
    embed.add_field(name="üîß M√≥dulos", value=len(bot.cogs), inline=True)
    embed.add_field(name="üì∂ Latencia", value=f"{round(bot.latency * 1000)}ms", inline=True)
    embed.add_field(name="‚è∞ Uptime", value=f"{days}d {hours}h {minutes}m", inline=True)
    embed.set_footer(text=f"Bot: {bot.user.name} | Discord.py {discord.__version__}")
    embed.set_thumbnail(url=bot.user.avatar.url if bot.user.avatar else None)
    await ctx.send(embed=embed)

@bot.command(name="help", aliases=["ayuda"], help="Muestra ayuda de comandos")
async def help_command(ctx, command: str = None):
    """Comando de ayuda personalizado"""
    if command:
        # Ayuda para comando espec√≠fico
        cmd = bot.get_command(command)
        if cmd:
            embed = discord.Embed(
                title=f"üìñ Ayuda: {cmd.name}",
                description=cmd.help or "Sin descripci√≥n disponible",
                color=0x0099ff
            )
            if cmd.aliases:
                embed.add_field(name="Aliases", value=", ".join(cmd.aliases), inline=False)
            embed.add_field(name="Uso", value=f"`!{cmd.name} {cmd.signature}`", inline=False)
        else:
            embed = discord.Embed(
                title="‚ùå Comando no encontrado",
                description=f"No existe el comando `{command}`",
                color=0xff0000
            )
    else:
        # Lista de comandos b√°sicos
        embed = discord.Embed(
            title="üìö Comandos Disponibles",
            description="Lista de comandos b√°sicos del bot",
            color=0x0099ff
        )
        
        basic_commands = ["ping", "info", "help"]
        embed.add_field(
            name="üîß B√°sicos",
            value="`" + "`, `".join(basic_commands) + "`",
            inline=False
        )
        
        if bot.cogs:
            cog_list = list(bot.cogs.keys())[:5]  # Primeros 5 m√≥dulos
            embed.add_field(
                name="üì¶ M√≥dulos Cargados",
                value="`" + "`, `".join(cog_list) + "`" + (f" y {len(bot.cogs) - 5} m√°s..." if len(bot.cogs) > 5 else ""),
                inline=False
            )
        
        embed.add_field(
            name="üí° Tip",
            value="Usa `!help <comando>` para obtener ayuda espec√≠fica de un comando",
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name="reload", help="Recarga todos los m√≥dulos")
@commands.is_owner()
async def reload_cogs(ctx):
    """Recargar todos los m√≥dulos (solo owner)"""
    await ctx.send("üîÑ Recargando m√≥dulos...")
    
    # Descargar m√≥dulos existentes
    for module in list(bot.extensions.keys()):
        try:
            await bot.unload_extension(module)
            logger.info(f"üîÑ M√≥dulo '{module.split('.')[-1]}' descargado")
        except Exception as e:
            logger.error(f"‚ùå Error descargando {module}: {e}")
    
    # Recargar m√≥dulos
    bot.cogs_loaded = False
    await bot.load_cogs()
    
    embed = discord.Embed(
        title="‚úÖ Recarga completa",
        description=f"M√≥dulos recargados: {len(bot.cogs)}",
        color=0x00ff00
    )
    await ctx.send(embed=embed)

@bot.command(name="shutdown", aliases=["stop"], help="Apaga el bot")
@commands.is_owner()
async def shutdown(ctx):
    """Apagar el bot de forma segura (solo owner)"""
    embed = discord.Embed(
        title="üëã Apagando bot...",
        description="El bot se desconectar√° en breve.",
        color=0xffa500
    )
    await ctx.send(embed=embed)
    logger.info("üõë Bot apagado por comando del owner")
    await bot.close()

# ========== FUNCI√ìN PRINCIPAL ==========

async def main():
    """Funci√≥n principal del bot"""
    logger.info("ü§ñ Iniciando bot...")
    logger.info("=" * 60)

    try:
        # Conectar a base de datos
        logger.info("üîå Conectando a base de datos...")
        db_success = await connect_db()
        if db_success:
            logger.info("‚úÖ Base de datos conectada")
        else:
            logger.warning("‚ö†Ô∏è Base de datos no disponible, continuando sin ella")

        # Iniciar bot
        logger.info("üöÄ Iniciando conexi√≥n con Discord...")
        async with bot:
            await bot.start(TOKEN)
            
    except discord.LoginFailure:
        logger.critical("‚ùå Error: Token de Discord inv√°lido")
        sys.exit(1)
    except discord.HTTPException as e:
        logger.critical(f"‚ùå Error de conexi√≥n HTTP: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("üõë Bot detenido por el usuario")
    except Exception as e:
        logger.critical(f"‚ùå Error inesperado: {e}", exc_info=True)
        sys.exit(1)
    finally:
        logger.info("üëã Bot desconectado")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üõë Programa interrumpido")
    except Exception as e:
        logger.critical(f"‚ùå Error cr√≠tico: {e}", exc_info=True)
        sys.exit(1)